/////DECLARE OBJECTS//////

DEFINE

    battery SET to empty list

    columnBasement SET to empty list ///Column desrving basements ///
    columnA SET to empty list  ///Columns deserving upper floors////
    columnB SET to empty list
    ...

    FOR # of columns L = A, B, C, ...
        FOR # of elevators in each column N = 1, 2, 3, ... ////Assumed here each columns have same # of elevators/////
            elevatorLN USING floor AND direction AND door AND on AND display
                Floor : floor
                Direction : direction  ///UP, DOWN, OR IDLE
                Queue SET to empty list ///Contain calls coming from floors (all going down)
                QueueUP SET to empty list ///COntains calls coming from RC (all going up)
                Door : door  //OPEN OR CLOSE
                Status : on
                Display : display ///Display current floor//

            ADD elevatorLN to columnL
        END FOR
        ADD columnL to battery
    END FOR

    FOR # of elevators in columnBasement N = 1, 2, 3, ...  ///Assume any # of basements///
        elevatorBaseN USING floor AND direction AND door AND on AND display
            Floor : floor
            Direction : direction
            Queue SET to empty list
            QueueDown SET to empty list
            Door : door
            Status : on
            Display : display 
        
        ADD elevatateBaseN to columnBasement
    END FOR

    ADD columnBasement to battery

    calledButtons SET to empty list
    interfaceButtons SET to empty list

    interfaceRC USING  display
        Display : display //Display which elevator and column to take///

    FOR floors in building excluding RC
        button USING status and floor
            Status : status
            Floor : floor
    END FOR

END DEFINE

//////DECLARE SEQUENCES ///////

/////NOTE that the quantity L/N = (floors excluding basements)/(# of elevators in each column)
///// is the number of floors deserved by each columns. If this number is not an integer, we can let
/////all columns except one serve (next integer smaller than L/N) floors, and let the remaining
////column serves the remaining floors. In all cases, this doesn't change the following logic by.


////Select elevator from a column////

SEQUENCE columnL.select USING button

    FOR # of elevators in each column N = 1, 2, 3, ...
        IF elevatorLN.Floor greater or equal than button.Floor AND elevatorLN.Direction is down THEN
            GET elevatorLN   //Select above elevator goin down first//
        END IF
    END FOR
    IF there's more than one selected elevatorLF THEN
        FOR selected elevators
            READ distance elevatoLN.Floor to button.Floor 
        END FOR
        GET closest to button.Floor     
        ADD button.Floor to elevatorLN.Queue
        REMOVE button from calledButtons
    END IF

    FOR # elevators in each column N = 1, 2, 3, ...
        IF elevatorLN.direction is idle THEN
            GET elevatorLN    //Select Idle elevator second//
        END IF
    END FOR
        FOR selected elevators
            GET distance of elevatorLN.Floor to button.Floor
        END FOR
        GET closest to button.Floor
        ADD button.Floor to elevatorLN.Queue
            IF elevatorLN.Floor is smaller than button.Floor THEN  //Change Idle to appropriate direction///
                SET elevatorLN.Direction to up
             ELSE IF elevatorLN.Floor is greater than button.Floor THEN
                SET elevatorLN.Direction to down
            END IF
        REMOVE button from calledButtons
    END IF

END SEQUENCE

////Same logic, but for basements////

SEQUENCE columnBasement.select USING button

    FOR # of elevators in each column N = 1, 2, 3, ...
        IF elevatorBaseN.Floor smaller or equal to button.Floor AND elevatorBaseN.Direction is up THEN
            GET elevatorBaseN
        END IF
    END FOR
    IF there's more than one selected elevatorBaseN THEN
         FOR selected elevators
            READ distance of elevatorBaseN.Floor to button.Floor
        END FOR
        GET closest to button.Floor
        ADD button.Floor to elevatorBaseN.Queue
        REMOVE button from calledButtons
    END IF

    FOR # elevators in each column N = 1, 2, 3, ...
        IF elevatorBaseN.direction = idle THEN
            GET elevatorBaseN
        END IF
    END FOR
    IF there's more than one selected elevatorBaseN THEN
         FOR selected elevators
            READ distance of elevatorBaseN.Floor to button.Floor
        END FOR
        GET closest to button.Floor
        ADD button.Floor to elevatorBaseN.Queue
            IF elevatorBaseN.Floor is smaller than button.Floor THEN
                SET elevatorBaseN.Direction to up
            ELSE IF elevatorBaseN.Floor is greater than button.Floor THEN
                SET elevatorBaseN.Direction to down
            END IF
        REMOVE button from calledButtons
    END IF

END SEQUENCE

////Dispatch call from floors to appropriate columns/////

SEQUENCE battery.dispatchCall USING button

    GET button.Floor
    
        IF button.Floor is a basement THEN
            CALL columnBasement.select WITH button
        IF button.Floor is in the interval [2, L/N] THEN
            CALL columnA.select WITH button
        ELSE IF button.Floor is in the interval [(L/N)+1, 2L/N] THEN
            CALL columnB.select WITH button
        ELSE IF button.floor is in the interval [(2L/N)+1, 3L/N] THEN
            CALL columnB.select WITH button
        ...
        END IF
    
END SEQUENCE

///Dispatch calls from RC interface, with similar logic for basements and upper floors/////

SEQUENCE interfaceRC.select USING number n

    IF n is either B1, B2, ... THEN
        GET columnBasement
    IF n is in the interval [2, L/N] THEN
        GET columnA
    ELSE IF n is in the interval [(L/N)+1, 2L/N] THEN
        GET columnB
    ELSE IF n is in the interval [(2L/N+1), 3L/N] THEN
        GET columnC
    ...
    END IF

    IF selected column is columnBasement THEN

        FOR EACH elevatorBaseN in columnBasement
            IF elevatorBaseN.Floor is RC AND elevatorBaseN.Direction is down THEN  
                GET this elevator    ///Select elevator at RC going down first///
            END IF
            
        END FOR
            FOR EACH selected elevatorBaseN
                GET distance of elevatorBaseN.Floor to n
            END FOR
            GET closest to n
            Add n to elevatorBaseN.QueueDown    ///Select elevator that stop closest to called floor///
            SET interfaceRC.Display to display selected elevator and column
            REMOVE n to interfaceButtons

        FOR EACH elevators in columnBasement
            IF elevatorBaseN.Floor is RC AND elevatorBaseN.Direction is Idle THEN
                GET this elevatorBaseN  //Select idle elevator at RC second///
            END IF
        END FOR
        IF there's more than one selected elevator THEN
            GET random one
            ADD n to elevatorBaseN.QueueUDown    ///Select any of them////
            SET interfaceRC.Display to display selected elevator and column
            REMOVE n to interfaceButtons
        END IF

        FOR elevatorBaseN in columnBasement
            IF elevatorBaseN.Direction is up
                GET this elevatorBaseN    //Select up elevator third, which necessarily goes to RC by construction; see below///
            END IF
        END FOR
            FOR EACH selected elevatorBaseN
                GET distance of elevatorBaseN.Floor to RC
            END FOR
            GET closest to RC
            ADD n to elevatorBaseN.QueueDown
            SET interfaceRC.Display to display selected elevator and column
            REMOVE n to interfaceButtons

    ELSE   ///Same logic for upper elevators///

        FOR EACH elevatorLN in selected column
            IF elevatorLN.Floor is RC AND elevatorLN.Direction is up THEN
                GET this elevatorLN
            END IF
        END FOR
            FOR EACH selected elevatorLN
                GET distance elevatorLN.Floor to n
            END FOR
            GET closest to n
            Add n to elevatorLN.QueueUp
            SET interfaceRC.Display to display selected elevator and column
            REMOVE n to interfaceButtons

        FOR EACH elevatorLN in selected column
            IF elevatorLN.Floor is RC AND elevatorLN.Direction is Idle THEN
                GET this elevatorLN
            END IF
        END FOR
            IF there's more than one selected elevator THEN
                GET random one
                ADD n to elevatorLN.QueueUp
                SET interfaceRC.Display to display selected elevator and column
                REMOVE n to interfaceButtons
                SET elevatorLN.Direction to up
            END IF

        FOR EACH elevatorLN in selected column
            IF elevatorLN.Direction is down
                GET this elevatorLN
            END IF
        END FOR
            FOR EACH selected elevatorLN
                GET distance from elevatorLN.Floor to RC
            END FOR
            GET closest to RC
            ADD n to elevatorLN.QueueUP
            SET interfaceRC.Display to display selected elevator and column
            REMOVE n to interfaceButtons
    END IF

END SEQUENCE

////Check if any remaining calls can be answered/////

SEQUENCE remainingCalls 

    FOR EACH button in calledButtons
        CALL battery.dispatchCall WITH button
    END FOR

    FOR items in interfaceButtons
        CAll interfaceRC.Select with item
    END FOR

END SEQUENCE

/////....open door...////

SEQUENCE elevator.open 

    SET elevator.Door to open

END SEQUENCE

////I'll let you gues what it does/////

SEQUENCE elevator.close 

    SET elevator.Door to close

END SEQUENCE

///Make single elevator move////

SEQUENCE elevator.move

    IF elevator.Direction is up THEN
        INCREMENT elevator.Floor by one
    ELSE IF elevator.Direction is down THEN
        DECREMENT elevator.Floor by one
    END IF

END SEQUENCE

////Check if there's a call on a given floor, or if a call is at destination///////
////Also check what to do if at RC or if there's no more call/////

SEQUENCE elevatorLN.checkFloors USING elevatorLN.Floor

    FOR EACH item IN elevator.Queue
            IF 
                elevatorLN.floor = item THEN
                    Elevator stops at floor
                    elevatorLN.open
                    READ for movement in doorframe
                        IF no movement for 5 seconds THEN
                            elevatorLN.close
                        END IF
                REMOVE item IN elevatorLN.Queue
                    IF elevator.Direction is up THEN
                        SET elevatorLN.Direction to down
                    END IF
            END IF
        END FOR

    FOR EACH item IN elevatorLN.QueueUp
            IF 
                elevator.floor = item THEN
                    Elevator stops at floor
                    elevator.open
                    READ for movement in doorframe
                        IF no movement for 5 seconds THEN
                            elevator.close
                        END IF
                REMOVE item IN elevatorLN.QueueUp
            END IF
        END FOR

    IF elevatorLN.Floor is RC THEN
        If elevatorLN.QueueUP is empty THEN      
            SET elevatorLN.Direction to Idle    //Ensure elevator stop at RC if there's no call and go up otherwise///
        ELSE
            SET elevatorLN.Direction to up      //Ensure elevator goes up to respond to the interfaceRC call//
    END IF

    IF both elevatorLN.Queue AND elevatorLN.QueueUp are empty THEN  //Ensure elevator stop going up if no more calls//
        IF elevatorLN.Direction is up THEN
            SET elevatorLN.Direction TO idle
        END IF
    END IF

END SEQUENCE

////Same, but for basements//////

SEQUENCE elevatorBaseN.checkFloors USING elevatorBaseN.Floor

    FOR EACH item IN elevatorBaseN.Queue
            IF 
                elevatorBaseN.floor equals item THEN
                    Elevator stops at floor
                    elevatorBaseN.open
                    READ for movement in doorframe
                        IF no movement for 5 seconds THEN
                            elevatorBaseN.close
                        END IF
                REMOVE item IN elevatorBaseN.Queue
                    IF elevatorBaseN.Direction is down THEN
                        SET elevatorBaseN.Direction to up
                    END IF
            END IF
        END FOR

    FOR EACH item IN elevatorBaseN.QueueDown
            IF 
                elevatorBaseN.floor equals item THEN
                    Elevator stops at floor
                    elevatorBaseN.open
                    READ for movement in doorframe
                        IF no movement for 5 seconds THEN
                            elevatorBaseN.close
                        END IF
                REMOVE item IN elevatorBaseN.QueueDown
            END IF
        END FOR

   IF elevatorBaseN.Floor is RC THEN
        If elevatorBaseN.QueueDown is empty THEN
            SET elevatorBaseN.Direction to Idle
        ELSE
            SET elevatorBaseN.Direction to down
    END IF

    IF both elevatorBaseN.Queue AND elevatorBaseN.QueueDown are empty THEN
            SET elevatorBaseN.Direction TO idle
    END IF


END SEQUENCE

////Make all elevators move simultaneously/////

SEQUENCE battery.move

    FOR # of elevators in each column N = 1, 2, 3, ...
        FOR # of columns L = A, B, C, ...
            CALL elevatorLN.move
            SET elevatorLN.Display to elevatorLN.Floor
            CALL elevatorLN.checkFloors USING elevatorLN.Floor
        END FOR
        CALL elevatorBaseN.move
        SET elevatorBaseN.Display to elevatorBaseN.Foor
        CALL elevatorBaseN.checkFloors USING elevatorBaseN.Floor
    END FOR

END SEQUENCE

///Set elevator to some rest floor//////

SEQUENCE elevatorLN.Rest

    IF elevatorLN.Direction is idle for x amount of time THEN
        IF elevatorLN.Floor is not lowest floor deserved by column excluding RC THEN
        ADD lowest floor deserved by column L to elevatorLN.QueueUp
        IF elevatorLN.Floor is RC THEN
            SET elevatorLN.Direction to up
        ELSE IF elevatorLN.Floor is above lowest floor THEN
            SET elevatorLN.Direction to down
        END IF
    END IF

END SEQUENCE

////Same for basements///////

SEQUENCE elevatorBaseN.Rest

    IF elevatorBaseN.Direction is idle for x amount of time THEN
        IF elevatorBaseN.Floor is not RC THEN
            ADD RC to elevatorBaseN.QueueDown
            SET elevatorBaseN.Direction to up
    END IF

END SEQUENCE

/////ELEVATORS DO THEIR WORK///////////

FOR EACH elevator

    WHILE elevator.Status is on

        IF button is pressed THEN               /////Call from floors
            ADD button to calledButtons
            CALL battery.dispatchCall WITH button
        END IF

        IF interfaceRC is pressed to floor n THEN   ////Call from RC
            ADD n to interfaceButtons
            CALL interfaceRC.select WITH n
        END IF

        For # of elevators in each columns N = 1, 2, 3, ... /////
            FOR # of selected columns L = A, B, C, ...      ////// SET elevator to given floors after a while
                CALL elevatorLN.Rest                        //////
            END FOR
            CALL elevatorBaseN.Rest
        END FOR

        CALL battery.move         ////Make everything move
        CALL remainingCalls       ////Listen for possible remaining calls

    END WHILE
END FOR






    