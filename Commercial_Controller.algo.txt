////// PRESENTATION IS @ https://www.youtube.com/watch?v=fLj_INmtBCI ///


/////DECLARE OBJECTS//////

DEFINE

    battery SET to empty list

    columnBasement SET to empty list ///Column desrving basements ///
    columnA SET to empty list  ///Columns deserving upper floors////
    columnB SET to empty list
    ...

    FOR # of columns L = A, B, C, ...
        FOR # of elevators in each column N = 1, 2, 3, ... ////Assumed here each columns have same # of elevators/////
            elevatorLN USING floor AND direction AND door AND on AND display
                Floor : floor
                Direction : direction  ///UP, DOWN, OR IDLE
                Queue SET to empty list ///Contain calls coming from floors (all going down)
                QueueUP SET to empty list ///COntains calls coming from RC (all going up)
                Door : door  //OPEN OR CLOSE
                Status : on
                Display : display ///Display current floor//

            ADD elevatorLN to columnL
        END FOR
        ADD columnL to battery
    END FOR

    FOR # of elevators in columnBasement N = 1, 2, 3, ...  ///Assume any # of basements///
        elevatorBaseN USING floor AND direction AND door AND on AND display
            Floor : floor
            Direction : direction
            Queue SET to empty list
            QueueDown SET to empty list
            Door : door
            Status : on
            Display : display 
        
        ADD elevatateBaseN to columnBasement
    END FOR

    ADD columnBasement to battery

    calledButtons SET to empty list
    interfaceButtons SET to empty list

    interfaceRC USING  display
        Display : display //Display which elevator and column to take///

    FOR floor in building excluding RC 
        button USING floor
            Floor : floor
    END FOR

END DEFINE

//////DECLARE SEQUENCES ///////

/////NOTE that the quantity F/L = (floors excluding basements)/(# of columns above ground)
///// is the number of floors deserved by each columns. If this number is not an integer, we can let
/////all columns except one serve (next integer smaller than F/L) floors, and let the remaining
////column serves the remaining floors. In all cases, this doesn't change the following logic by.


////Select elevator from a column////

SEQUENCE columnL.select USING button

    FOR # of elevators in each column N = 1, 2, 3, ...
        IF elevatorLN.Floor greater or equal than button.Floor AND elevatorLN.Direction is down THEN
            GET elevatorLN   //Select above elevator goin down first//
        END IF
    END FOR
    IF there's more than one selected elevatorLF THEN
        FOR selected elevators
            READ distance elevatoLN.Floor to button.Floor 
        END FOR
        GET closest to button.Floor     
        ADD button.Floor to elevatorLN.Queue
        REMOVE button from calledButtons
    END IF

    FOR # elevators in each column N = 1, 2, 3, ...
        IF elevatorLN.direction is idle THEN
            GET elevatorLN    //Select Idle elevator second//
        END IF
    END FOR
        FOR selected elevators
            GET distance of elevatorLN.Floor to button.Floor
        END FOR
        GET closest to button.Floor
        ADD button.Floor to elevatorLN.Queue
            IF elevatorLN.Floor is smaller than button.Floor THEN  //Change Idle to appropriate direction///
                SET elevatorLN.Direction to up
             ELSE IF elevatorLN.Floor is greater than button.Floor THEN
                SET elevatorLN.Direction to down
            END IF
        REMOVE button from calledButtons
    END IF

END SEQUENCE

////Same logic, but for basements////

SEQUENCE columnBasement.select USING button

    FOR # of elevators in each column N = 1, 2, 3, ...
        IF elevatorBaseN.Floor smaller or equal to button.Floor AND elevatorBaseN.Direction is up THEN
            GET elevatorBaseN
        END IF
    END FOR
    IF there's more than one selected elevatorBaseN THEN
         FOR selected elevators
            READ distance of elevatorBaseN.Floor to button.Floor
        END FOR
        GET closest to button.Floor
        ADD button.Floor to elevatorBaseN.Queue
        REMOVE button from calledButtons
    END IF

    FOR # elevators in each column N = 1, 2, 3, ...
        IF elevatorBaseN.direction = idle THEN
            GET elevatorBaseN
        END IF
    END FOR
    IF there's more than one selected elevatorBaseN THEN
         FOR selected elevators
            READ distance of elevatorBaseN.Floor to button.Floor
        END FOR
        GET closest to button.Floor
        ADD button.Floor to elevatorBaseN.Queue
            IF elevatorBaseN.Floor is smaller than button.Floor THEN
                SET elevatorBaseN.Direction to up
            ELSE IF elevatorBaseN.Floor is greater than button.Floor THEN
                SET elevatorBaseN.Direction to down
            END IF
        REMOVE button from calledButtons
    END IF

END SEQUENCE

////Dispatch call from floors to appropriate columns/////

SEQUENCE battery.dispatchCall USING button

    GET button.Floor
    
        IF button.Floor is a basement THEN
            CALL columnBasement.select WITH button
        IF button.Floor is in the interval [2, F/L] THEN
            CALL columnA.select WITH button
        ELSE IF button.Floor is in the interval [(F/L)+1, 2F/L] THEN
            CALL columnB.select WITH button
        ELSE IF button.floor is in the interval [(2F/L)+1, 3F/L] THEN
            CALL columnC.select WITH button
        ...
        END IF
    
END SEQUENCE

///Dispatch calls from RC interface, with similar logic for basements and upper floors/////

SEQUENCE interfaceRC.select USING number n

    IF n is either B1, B2, ... THEN
        GET columnBasement
    IF n is in the interval [2, F/L] THEN
        GET columnA
    ELSE IF n is in the interval [(F/L)+1, 2F/L] THEN
        GET columnB
    ELSE IF n is in the interval [(2F/L)+1, 3F/L] THEN
        GET columnC
    ...
    END IF

    IF selected column is columnBasement THEN

        FOR EACH elevatorBaseN in columnBasement
            IF elevatorBaseN.Floor is RC AND elevatorBaseN.Direction is down THEN  
                GET this elevator    ///Select elevator at RC going down first///
            END IF
            
        END FOR
            FOR EACH selected elevatorBaseN
                GET distance of elevatorBaseN.Floor to n
            END FOR
            GET closest to n
            Add n to elevatorBaseN.QueueDown    ///Select elevator that stop closest to called floor///
            SET interfaceRC.Display to display selected elevator and column
            REMOVE n to interfaceButtons

        FOR EACH elevators in columnBasement
            IF elevatorBaseN.Floor is RC AND elevatorBaseN.Direction is Idle THEN
                GET this elevatorBaseN  //Select idle elevator at RC second///
            END IF
        END FOR
        IF there's more than one selected elevator THEN
            GET random one
            ADD n to elevatorBaseN.QueueUDown    ///Select any of them////
            SET interfaceRC.Display to display selected elevator and column
            REMOVE n to interfaceButtons
        END IF

        FOR elevatorBaseN in columnBasement
            IF elevatorBaseN.Direction is up
                GET this elevatorBaseN    //Select up elevator third, which necessarily goes to RC by construction; see below///
            END IF
        END FOR
            FOR EACH selected elevatorBaseN
                GET distance of elevatorBaseN.Floor to RC
            END FOR
            GET closest to RC
            ADD n to elevatorBaseN.QueueDown
            SET interfaceRC.Display to display selected elevator and column
            REMOVE n to interfaceButtons

    ELSE   ///Same logic for upper elevators///

        FOR EACH elevatorLN in selected column
            IF elevatorLN.Floor is RC AND elevatorLN.Direction is up THEN
                GET this elevatorLN
            END IF
        END FOR
            FOR EACH selected elevatorLN
                GET distance elevatorLN.Floor to n
            END FOR
            GET closest to n
            Add n to elevatorLN.QueueUp
            SET interfaceRC.Display to display selected elevator and column
            REMOVE n to interfaceButtons

        FOR EACH elevatorLN in selected column
            IF elevatorLN.Floor is RC AND elevatorLN.Direction is Idle THEN
                GET this elevatorLN
            END IF
        END FOR
            IF there's more than one selected elevator THEN
                GET random one
                ADD n to elevatorLN.QueueUp
                SET interfaceRC.Display to display selected elevator and column
                REMOVE n to interfaceButtons
                SET elevatorLN.Direction to up
            END IF

        FOR EACH elevatorLN in selected column
            IF elevatorLN.Direction is down
                GET this elevatorLN
            END IF
        END FOR
            FOR EACH selected elevatorLN
                GET distance from elevatorLN.Floor to RC
            END FOR
            GET closest to RC
            ADD n to elevatorLN.QueueUP
            SET interfaceRC.Display to display selected elevator and column
            REMOVE n to interfaceButtons
    END IF

END SEQUENCE

////Check if any remaining calls can be answered/////

SEQUENCE remainingCalls 

    FOR EACH button in calledButtons
        CALL battery.dispatchCall WITH button
    END FOR

    FOR items in interfaceButtons
        CAll interfaceRC.Select with item
    END FOR

END SEQUENCE

/////....open door...////

SEQUENCE elevator.open 

    SET elevator.Door to open

END SEQUENCE

////I'll let you gues what it does/////

SEQUENCE elevator.close 

    SET elevator.Door to close

END SEQUENCE

///Make single elevator move////

SEQUENCE elevator.move

    IF elevator.Direction is up THEN
        INCREMENT elevator.Floor by one
    ELSE IF elevator.Direction is down THEN
        DECREMENT elevator.Floor by one
    END IF

END SEQUENCE

////Check if there's a call on a given floor, or if a call is at destination///////
////Also check what to do if at RC or if there's no more call/////

SEQUENCE elevatorLN.checkFloors USING elevatorLN.Floor

    FOR EACH item IN elevator.Queue
            IF 
                elevatorLN.floor = item THEN
                    Elevator stops at floor
                    elevatorLN.open
                    READ for movement in doorframe
                        IF no movement for 5 seconds THEN
                            elevatorLN.close
                        END IF
                REMOVE item IN elevatorLN.Queue
                    IF elevator.Direction is up THEN
                        SET elevatorLN.Direction to down
                    END IF
            END IF
        END FOR

    FOR EACH item IN elevatorLN.QueueUp
            IF 
                elevator.floor = item THEN
                    Elevator stops at floor
                    elevator.open
                    READ for movement in doorframe
                        IF no movement for 5 seconds THEN
                            elevator.close
                        END IF
                REMOVE item IN elevatorLN.QueueUp
            END IF
        END FOR

    IF elevatorLN.Floor is RC THEN
        Elevator stops at floor
        elevatorLN.open
        READ for movement in doorframe
            IF no movement for 5 seconds THEN
                elevatorLN.close
            END IF
        If elevatorLN.QueueUP is empty THEN      
            SET elevatorLN.Direction to Idle    //Ensure elevator stop at RC if there's no call and go up otherwise///
        ELSE
            SET elevatorLN.Direction to up      //Ensure elevator goes up to respond to the interfaceRC call//
            Remove columnL and elevatorLN from interfaceRC.Display ///Update InterfaceRC///
    END IF

    IF both elevatorLN.Queue AND elevatorLN.QueueUp are empty THEN  //Ensure elevator stop going up if no more calls//
        IF elevatorLN.Direction is up THEN
            SET elevatorLN.Direction TO idle
        ELSE IF elevatorLN.Direction is down and elevator.Floor is RC THEN
            SET elevator.Direction to idle
        END IF
    END IF

    

END SEQUENCE

////Same, but for basements//////

SEQUENCE elevatorBaseN.checkFloors USING elevatorBaseN.Floor

    FOR EACH item IN elevatorBaseN.Queue
            IF elevatorBaseN.floor equals item THEN
                Elevator stops at floor
                elevatorBaseN.open
                READ for movement in doorframe
                    IF no movement for 5 seconds THEN
                        elevatorBaseN.close
                    END IF
                REMOVE item IN elevatorBaseN.Queue
                    IF elevatorBaseN.Direction is down THEN
                        SET elevatorBaseN.Direction to up
                    END IF
            END IF
        END FOR

    FOR EACH item IN elevatorBaseN.QueueDown
            IF elevatorBaseN.floor equals item THEN
                Elevator stops at floor
                elevatorBaseN.open
                READ for movement in doorframe
                    IF no movement for 5 seconds THEN
                        elevatorBaseN.close
                    END IF
                REMOVE item IN elevatorBaseN.QueueDown
            END IF
    END FOR

   IF elevatorBaseN.Floor is RC THEN
        Elevator stops at floor
        elevatorBaseN.open
        READ for movement in doorframe
            IF no movement for 5 seconds THEN
                elevatorBaseN.close
            END IF
        If elevatorBaseN.QueueDown is empty THEN
            SET elevatorBaseN.Direction to Idle
        ELSE
            SET elevatorBaseN.Direction to down
            REMOVE columnBasement and elevatorBaseN from interfaceRC.Display ///Update InterfaceRC///
        END IF
    END IF

    IF both elevatorBaseN.Queue AND elevatorBaseN.QueueDown are empty THEN
            SET elevatorBaseN.Direction TO idle
    ELSE IF elevatorBaseN.Direction is up and elevator.Floor is RC THEN
            SET elevatorBaseN.Direction to idle
    END IF


END SEQUENCE

////Make all elevators move simultaneously/////

SEQUENCE battery.move

    FOR # of elevators in each column N = 1, 2, 3, ...
        FOR # of columns L = A, B, C, ...
            CALL elevatorLN.move
            SET elevatorLN.Display to elevatorLN.Floor
            CALL elevatorLN.checkFloors USING elevatorLN.Floor
        END FOR
        CALL elevatorBaseN.move
        SET elevatorBaseN.Display to elevatorBaseN.Foor
        CALL elevatorBaseN.checkFloors USING elevatorBaseN.Floor
    END FOR

END SEQUENCE

///Set elevator to some rest floor//////

SEQUENCE elevatorLN.Rest

    IF elevatorLN.Direction is idle for x amount of time THEN
        IF elevatorLN.Floor is not lowest floor deserved by column excluding RC THEN
        ADD lowest floor deserved by column L to elevatorLN.QueueUp
        IF elevatorLN.Floor is RC THEN
            SET elevatorLN.Direction to up
        ELSE IF elevatorLN.Floor is above lowest floor THEN
            SET elevatorLN.Direction to down
        END IF
    END IF

END SEQUENCE

////Same for basements///////

SEQUENCE elevatorBaseN.Rest

    IF elevatorBaseN.Direction is idle for x amount of time THEN
        IF elevatorBaseN.Floor is not RC THEN
            ADD RC to elevatorBaseN.QueueDown
            SET elevatorBaseN.Direction to up
    END IF

END SEQUENCE

/////ELEVATORS DO THEIR WORK///////////

FOR EACH elevator

    WHILE elevator.Status is on

        IF button is pressed THEN               /////Call from floors
            ADD button to calledButtons
            CALL battery.dispatchCall WITH button
        END IF

        IF interfaceRC is pressed to floor n THEN   ////Call from RC
            ADD n to interfaceButtons
            CALL interfaceRC.select WITH n
        END IF

        For # of elevators in each columns N = 1, 2, 3, ... /////
            FOR # of selected columns L = A, B, C, ...      ////// SET elevator to given floors after a while
                CALL elevatorLN.Rest                        //////
            END FOR
            CALL elevatorBaseN.Rest
        END FOR

        CALL battery.move         ////Make everything move
        CALL remainingCalls       ////Listen for possible remaining calls

    END WHILE
END FOR


/////TEST WITH SCENARIO 3/////////////

///Initial Values: F = 60, L = 3, so each columns deserve 20 floors
//So that columnA is the above columnBasement, columnB is the above columnA, and so forth
///ElevatorD1.Floor = 58, elevatorD1.Direction is down, Queue and QueueUP are empty
///...D2.Floor is 50, ..D2.Direction is up, Queue is empty, Queup up contain 60
///...D3.Floor is 46, ..D3.Direction up, Queue is empty, QueueUp contain 58
///..D4.Floor is RC, ..D4.Direction is up, Queue is empty, QueueUP contain 54
///...D5.Floor is 60, ..D5.DIrection is down, Queue and QueueUP are empty


*Start While Loop*
*A call at floor 54 is made*

ADD button with button.Floor = 54 to calledButtons list
CALL battery.Dispatch WITH this button
    GET button.Floor 
    Since 54 is in the interval [40,60], 
        CALL columnD.select WITH button having button.Floor = 54
                FOR N = 1, 2, 3, 4, 5
                    CHECK for elevatorDN with elevatorDN.Floor above 54 and going down
                        BOTH D1 AND D5 are selected
                    CHECK distance of both from 54
                        D1 is closer
                        ADD 54 to elevatorD1.Queue
                        REMOVE button from calledButtons list

FOR EACH elevator CALL elevator.Rest 
    Do nothing since no elevator is idle

CALL battery.move
    Elevators move up or down if possible
    Change their display to current floor
    CALL elevator.checkFloors
        Do nothing for now

CALL remainingCalls
    DO nothing for now

CONTINUE Loop and make things move

*When elevatorD1.Floor reach floor 54, 

elevatorD1.checkFloors :

elevatorD1.Floor = elevator.Queue
    Open door, wait, close door
    REMOVE 54 from elevatorD1.Queue
    Won't change direction

CONTINUE LOOP until elevatorD1.Floor is RC

Then by elevatorsD1.checkfloors, 
    since elevatorD1.FLoor is RC,
    Open, wait and close door
    since both queue and queue up are empty and elevatorD1.Floor is RC,
    SET elevatorD1.Direction to Idle

*Voila! Person arrived at destination!*

////ADDITIONAL REQUIREMENTS///////

///Logic of prioritization of elevators is already taken care of in the algorithm/////

/////Logic back to the origin//////

///Is it better to have a lift waiting on the ground floor?///
Already implemented above

///Safety logic///
//Routines checking system status before using them////

ADD properties Sensor : online AND SensorStatus : working TO elevators  ///Will diagnose for any problem///

IF elevator.Sensor is offline THEN                //Ensure the elevator stops if sensor is off//
    IF elevator.Direction is idle THEN
        CALL elevator.open
        SET elevator.Display to warning message
        SET elevator.Status to off
    ELSE
        Elevator stops at next floor
        CALL elevator.open
        EMPTY elevator.Queue AND elevator.QueueUp (or.QueueDown)
        Set elevator.Display to warning message
        Set elevator.Status to off
    END IF
ELSE


IF elevator.Sensor is online AND detect a problem THEN   //Stop elevator if a problem is diagnosed///
    SET SensorStatus to not working
    IF elevator.Direction is idle THEN
        CALL elevator.open
        SET elevator.Display to warning message
        SET elevator.Status to off
    ELSE
        Elevator stops at next floor
        CALL elevator.open
        EMPTY elevator.Queue AND elevator.QueueUp (or.QueueDown)
        Set elevator.Display to warning message
        Set elevator.Status to off
    END IF
ELSE










    